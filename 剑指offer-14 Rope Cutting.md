给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。



**Example:**
```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

## Solution - I Mathematics

java
```python
class Solution {
    public int integerBreak(int n) {
        if (n <= 3) return n - 1;
        
        int a = n / 3, b = n % 3;
        
        if (b == 0) return (int)Math.pow(3, a);
        if (b == 1) return (int)Math.pow(3, a-1)*4;
        return (int)Math.pow(3, a)*2;
    }
}
```
执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：35 MB, 在所有 Java 提交中击败了89.32%的用户

**复杂度分析**

- 时间复杂度 O(1) ： 仅有求整、求余、次方运算。
  - 求整和求余运算：查阅资料，提到不超过机器数的整数可以看作是 O(1)；
  - 幂运算：查阅资料，提到浮点取幂为 O(1)。
- 空间复杂度 O(1) ： a 和 b 使用常数大小额外空间。

## Solution - II DP



```c++

```

执行用时：16 ms, 在所有 C++ 提交中击败了86.13%的用户

内存消耗：9.3 MB, 在所有 C++ 提交中击败了58.51%的用户

**Space Complexity** : O(1)

Attention

- 借用原始数组降低空间复杂度