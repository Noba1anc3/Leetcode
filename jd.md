## 京东 - 零售 - 广告

2021.07.22 - 2021.07.26 - 2021.07.27

## 一面

### 技术栈

- 介绍一下你都做过哪些东西，用到了哪些技术
  - 分别介绍在学校做科研和实习做工程的工作内容

### 简历

- 介绍一下你在字节跳动实习的工作内容

### 操作系统

- 进程之间同步有哪些方式
  - **匿名管道(Pipes)**：用于具有**亲缘关系**的**父子进程间或者兄弟进程之间**的通信，以**内存文件**的形式存在。
  - **有名管道(Names Pipes)**：遵循先进先出，**以磁盘文件的形式存在**，可以实现本机**任意两个进程**通信。

  - **消息队列(Message Queuing)**：消息队列是消息的链表，由消息队列标识符标识。管道和消息队列的通信数据都是**先进先出**的原则。与管道不同的是消息队列**存放在内核中**，只有在内核重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

  - **信号(Signal)**：信号用于通知接收进程**某个事件已经发生**；（对于异常情况下的工作模式，就需要用「信号」的方式来通知进程，信号事件的来源主要有**硬件来源**（如键盘 Cltr+C ）和**软件来源**（如 kill 命令）。比如，**Ctrl+C** 产生 SIGINT 信号，表示终止该进程，**Ctrl+Z** 产生 SIGSTP，表示停止该进程，但还未结束）

  - **信号量(Semaphores)**：信号量是一个计数器，用于**多进程对共享数据的访问**，信号量的意图在于进程间**同步**。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

  - **共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要**依靠同步操作**，如互斥锁和信号量等。最有用的进程间通信方式。

  - **套接字(Sockets)**: 主要用于在**客户端和服务器**之间通过**网络**进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
- 怎么做分布式的互斥
  - 传统的单机达到互斥的方法有互斥锁,条件变量,读写锁,共享内存,信号量,内存屏障等,这些方法在分布式系统中通通不可用,在分布式系统中**消息传递**是实现互斥的唯一的方法.
  - 分布式互斥算法
    - 集中式算法(Centralized Algorithm)
      - 在所有的节点中引入一个**协调者**,这个协调者负责所有节点申请资源请求的调度.每个节点想要申请资源需要向协调者发送请求,如果当前节点没有人使用的话,协调者就授权这个节点进行访问.对于协调者来说维护一个队列,用先来后到的顺序为没有申请到资源的节点排序,当得到资源的节点执行完毕以后返回一个**消息**代表使用完毕,这个时候协调者再次分配.
      - 一次申请资源的交互中需要**三次消息交互**:
        1. 节点向协调者请求资源.
        2. 协调者给予权限.
        3. 节点完成以后返回释放消息.
      - 优点
        - 通信成本较低
        - 直观,简单
        - 所有的节点只需要与协调者通信 
      - 缺点
        - 可用性
          - 协调者宕机,整个服务直接不可用,假如重启以后信息丢失,有可能破坏一致性假设. 
        - 效率瓶颈
          - 所有的压力全部落在了协调者上
    - 分布式算法(Distributed Algorithm)
      - 基于请求的算法(Permission Based Algorithm)
        - 所有节点互相连接,形成**网状的拓扑结构**,在每次使用资源的时候向其他节点发起资源的申请,如果获取全票同意的话则获取资源使用权.在使用过程中也可能有其他节点同样请求资源,发送请求的双方都可以得到对方使用资源的消息,这个时候对比出时间戳最小的获取资源访问权,得到资源访问权的节点要**维护一个队列,存储其他申请请求**,在完成资源访问以后向其他申请资源的节点发送同意使用资源的消息,不申请资源的节点在收到其他申请资源的请求时直接同意.
        - 假设集群有N个节点:
          1. 向其他N-1个节点发送请求资源消息.需要N-1次交互.
          2. 需要接收N-1个节点的回复消息,需要N-1次交互.
          3. 每个节点每次申请资源需要2 * (N-1)次信息交互.而且当集群内每个节点都进行资源申请的时候会有2 * N * (N-1)次交互,也就是说**随着集群扩展,通信成本平方上涨** 
        - 当系统内需要访问临界资源的程序增多时,容易产生**“信令风暴”**,也就是程序收到的请求完全超过了自己的处理能力,而导致自己正常的业务无法开展.
        - **通信成本高**。适合**节点数目少,变动不频繁的系统**, 且适用于P2P结构,因为每个程序之间都需要互相交互. HDFS就是一个典型的运用场景. 
      - 基于令牌的算法(Token Based Algorithm)
        - 所有程序构成一个**逻辑上的环结构**,令牌按照顺时针(或逆时针)方向在程序之间传递,收到令牌的程序有权访问临界资源,访问完成后将令牌传送到下一个程序.若该程序不需要访问临界资源,则直接把令牌传送给下一个程序. 
        - 每个节点在使用资源前不需要向每一个节点请求了,只需要传递令牌即可,得到令牌的节点获取资源,这样在一个周期内全部节点都有机会使用资源,不需要的话直接转发就可以了.当然这也带来一些**无效的通信成本,且降低了实时性**.因为就算只有一个节点请求资源,全部的节点都需要进行信息传递,而且**考虑到节点宕机,每个节点也不能仅存储自己的下一位节点**.令牌环算法非常适合通信模式为令牌环方式的分布式系统.
        - 优点
          - 通信效率高
          - 可用性不差
          - 适用于请求资源频繁且使用时间短的情况
        - 缺点
          - 容易带来大量的无用通信

### 数据结构

- 读多写少的情况用什么数据结构
  - 提到最近用c++刷题时感受到的`unordered_set`和`set`之间的区别
    - `unordered_set`基于哈希，搜索的时间复杂度可以下降至O(1)
    - `set`基于红黑树，查询的时间复杂度为O(log n)

- 哈希和树作为数据结构有什么区别？
  - 哈希只适用于以`O(1)`的时间复杂度进行增删查，但无法快速得到最小值
  - 树以`O(logn)`的时间复杂度支持增删查，但能以`O(1)`的复杂度得到最小值

- 哈希遇到冲突了怎么解决

  - 一般来说啊，实现哈希表我们可以采用两种方法：

    1. 数组+链表

    2. 数组+二叉树

  - 哈希表是通过将**关键值**通过一个**散列函数**加工处理之后得到一个值，这个值是数据存放的位置，我们可以根据这个值快速的找到我们想要的数据

  - 哈希冲突解决方法

    - **开放寻址法（线性探测法，闭散列）**
      - **线性探测**
        - 在原来值的基础上往后加一个单位，直至不发生哈希冲突。 
      - **再平方探测**
        - 在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等。直至不发生哈希冲突。
      - **伪随机探测**
        - 在原来值的基础上加上随机数，直至不发生哈希冲突。 
    - **链式地址法（拉链法，开散列）**
      - 对于相同的值，使用链表进行连接
      - 如果冲突过多，链表会变得比较长，怎么处理呢？Java中如果链表长度大于等于8的话，**链表就会转换成红黑树结构**，当然如果长度小于等于6的话，就会还原链表。以此来解决链表过长导致的性能问题。 
    - **建立公共溢出区** 
      - 建立公共溢出区存储所有哈希冲突的数据。 
    - **再哈希法**
      - 对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。 

  - 哈希表扩容

    -  一般会有一个**增长因子**的概念，也叫作负载因子，简单点说就是已经被占的位置与总位置的一个百分比，比如一共十个位置，现在已经占了七个位置，就触发了扩容机制，因为它的增长因子是0.7
    -  扩容不是简单的把数组扩大，而是新创建一个数组是原来的2倍，然后**把原数组的所有Entry都重新Hash一遍放到新的数组**。 

### 计算机网络

- TCP和UDP之间的区别是什么

  - UDP 用户数据报协议

    - **面向无连接**
      - 不需要和TCP一样在发送数据前进行**三次握手**建立连接，想发数据就可以开始发送
      - 只是数据报文的搬运工，**不会对数据报文拆分或拼接** 
    - **提供单播，多播，广播功能**
    - **面向报文**
      - 发送方的UDP对应用程序交下来的报文，添加首部后就向下交付IP层 
      - 既不合并，也不拆分，而是**保留报文的边界**。因此，应用程序必须选择合适大小的报文
    - **不可靠性**
      - 无连接，不关心对方是否收到
      - 没有拥塞控制
    - **头部开销小，高效传输报文**

  - TCP 传输控制协议

    - 建立连接三次握手
      - 客户端向服务端发送连接请求报文段。该报文段中包含自身的**数据通讯初始序号**。请求发送后，客户端便进入 **SYN-SENT** 状态。 
      - 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 **SYN-RECEIVED** 状态。 
      - 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 **ESTABLISHED** 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 
    - 断开连接四次握手
      - 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 
      - B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 **CLOSE_WAIT** 状态，此时表明 **A 到 B 的连接已经释放**，不再接收 A 发的数据了。但是因为 **TCP 连接是双向的，所以 B 仍旧可以发送数据给 A**。 
      - B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 **LAST-ACK** 状态。 
      - A 收到释放请求后，向 B 发送确认应答，此时 A 进入 **TIME-WAIT** 状态。该状态会持续 **2MSL**（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 **CLOSED** 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 
    - **面向连接**
      - 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 
    - **仅支持单播传输**
      -  每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 
    - **面向字节流**
      - TCP不像UDP那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 
    - **可靠传输**
      - 对于可靠传输，判断丢包，误码靠的是TCP的**段编号**以及**确认号**。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的**按序接收**。接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被**重传**。 
    - **拥塞控制** 
      - 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞 
    - **全双工通信** 
      - TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的**两端都设有缓存**，用来临时存放双向通信的数据。

  - |              | UDP                                        | TCP                                    |
    | :----------- | :----------------------------------------- | -------------------------------------- |
    | 是否连接     | 无连接                                     | 面向连接                               |
    | 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
    | 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
    | 传输方式     | 面向报文                                   | 面向字节流                             |
    | 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
    | 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

### 深度学习

- 怎样设计特征，怎样知道特征有没有用

### 职业发展

- 你未来的职业发展希望是什么样的，想做哪些内容

### 我的问题

- 进去之后会做什么内容？
  - 离线和在线的工作都会有，离线主要是模型的数据准备，模型训练，在线主要是inference
  - 语言上c++，python比较多，其次java
  - 框架主要用tensorflow，也会用到pytorch，cuda
  - 技术主要是深度学习，会用到强化学习和无监督学习；机器学习很少，偶尔会用xgboost
  - 模型主要是ctr，cvr，转化率模型
  - 这边不做业务，是业务的上游

## 二面

### 简历

- 介绍一下你在字节实习的工作内容（详细）
  - 我在字节实习期间工作的目标是将强时效个性化词加入到TikTok搜索框提示词和猜你想搜召回当中。强时效词可以简单理解为微博热搜这种紧随时事的词，将这些词进行个性化推荐。为此，需要建立起强时效词从离线召回到在线进候选的完整链路。
  - 首先说一下离线部分，强时效个性化词离线挖掘分为召回，合并，预处理，过滤，后处理和送下游任务这几个部分。共设计了五路召回，基本思路为使用SQL基于一定逻辑对用户搜索log进行大数据筛选，得到前1000条强时效词目。接入纠错和分词服务进行预处理。因为会有许多语义类似的条目，接入了bert embedding进行消重。而后计算词条搜索突增量，查询法务安全部门提供的离线安全结论接口进行过滤。后处理接入NER服务对命名实体首字母大写化，并对人名词进行搜后搜挖掘。同时在挖掘过程中重要的结点建设了完整的监控。
  - 将离线挖掘封装为服务并上线，将挖掘结果发往三处下游，其一是将结果封装成json通过kafka消息队列发送给下游热点挖掘团队，其二是通过机器人在飞书群定时反馈给海外运营。由于海外的法务安全规则繁多，这种词条需要逐一进行人审才能上线，因此要将结果发送到字节研发的众包平台送审。
  - 接下来是在字节自研的众包平台上搭建审核队列，设计前端界面展示词条及其相关信息，应产品要求设计了时效性标注，词条驳回，押后及改词这几种审核操作，编写审出操作的后端回调方法，实现相应逻辑，将词条的时效性写入kafka，sql和redis进行缓存。通过字节离线数据流框架以tbase作为中介将结果刷入正排服务器当中。
  - 为了监控审核过程中进审审出量，审出率，审核延时等情况，将审核平台上的审出结果hive表同步clickhouse表，进行vba编程提取审出记录中的有效内容，建设完整的审核情况分析看板。
  - 接下来是在线部分的工作，首先编写了带有语义消重及打散机制的强时效个性化词召回类和头文件，其次为了将这路新召回加入原有推荐系统在线部分，需要修改基于DAG也就是有向无环图的在线部分框架拓扑及配置依赖。测试正确加入召回后开展了一周50流量的AB实验，实验效果挺不错，显著提升了点击pv和ctr，最后正式上线。

### 代码能力

- [实现一个队列](https://github.com/Noba1anc3/Leetcode/blob/master/622%20Design%20Circular%20Queue.md)
  - 初始化队头与队尾指针均为-1
  - 判空：头指针为-1
  - 判满：尾指针+1后对size取余等于头指针
  - 取队首：若队列不空，则返回头指针处队列值
  - 取队尾：若队列不空，则返回尾指针处队列值
  - 入队：若队列未满，如果队列为空，头指针+1；尾指针+1后对size取余，将值赋给尾指针处队列值
  - 出队：若队列未空，如果头尾指针相等，将二者修改为-1；头指针+1后对size取余

### 语言特性

- 介绍一下c++的虚函数
- 介绍一下c++的多态
- 在类继承时，先初始化的是基类还是子类的构造函数
- c++的垃圾回收了解吗

 ### 操作系统

- 都知道哪些内存页面置换算法？
  - **OPT（最佳页面置换算法）**：被换出的页面将是**最长时间内不再被访问**， 可以获得**最低的缺页率**。
  - **FIFO（先进先出）** : 总是淘汰最先进入内存的页面，即选择在内存中**驻留时间最久的页面进行淘汰**。
  - **LRU （Least Recently Used）（最近最久未使用）**：将最近最久未使用的页面换出。需要在内存中维护一个所有页面的链表。**当一个页面被访问时，将这个页面移到链表表头。**这样保证链表表尾的页面是最近最久未访问的。
  - **LFU （Least Frequently Used）（最近最少使用）**：选择在之前使用最少的页面作为淘汰页。
- 最近最久未使用页面置换算法你会怎样实现？
  - 用**双向链表**实现，从链头到链尾的页面被使用时间越来越久远
    - 查找某页的时间复杂度`O(n)`
    - 找到需要被替换的页面的时间复杂度`O(1) `
  - 如果想优化一下查找页面的时间复杂度，你会怎样做？
    - 考虑使用**基于键值对的最小堆**，也就是`priority_queue<pair<>>`这一数据结构来记录这些页面，pair键为上次访问该页面的时间戳，值为页面号。这样最小堆仍然可以保证以`O(1)`的复杂度来找到被替换的页面。同时基于树结构的堆可以使得搜索指定页面能在`O(log n)`的时间复杂度完成。
  - 如果想再进一步优化查找页面的时间复杂度，你会怎么做？
    - 考虑到`O(log n)`如果想进一步降低的话，就是`O(1)`的时间复杂度了。这需要哈希这一数据结构的助力。但哈希可以支持快速定位到指定页面，但就不能保证在`O(1)`的时间复杂度找到需要被替换的页面了。
  - 与面试官交流我的想法后，面试官提议也许你可以尝试将多种数据结构进行组合，就像上面提到的基于键值对的最小堆
    - 想到用**哈希表+双向链表**的组合解决该问题
      - 更新内存页时
        - 先通过哈希表查找**内存页在链表中的位置**
        - 如果找到了该内存页
          - 将该内存页置于链表表头处
        - 如果没找到该内存页
          - 如果哈希表长度尚未超过内存页上限，新建内存页，将该内存页插入到链表表头处，并将该内存页到链表表头的映射添加到哈希表当中。
          - 如果哈希表长度达到了内存页上限。找到链表表尾内存页，将其从链表中去掉，并将以该内存页为键的映射从哈希表中删除。而后新建内存页，将该内存页插入到链表表头处，并将该内存页到链表表头的映射添加到哈希表当中。
      - 查找内存页时
        - 通过哈希表查找内存页在链表中的位置
        - 如果找到了该内存页，将该内存页置于链表表头处，返回内存页信息；否则，返回错误。
      - [在Leetcode上找到了该题目](https://github.com/Noba1anc3/Leetcode/blob/master/146%20LRU%20Cache.md)

### 深度学习

- 是否用过tensorflow，tf1和tf2之间有什么区别
  - tensorflow1是预定义占位符和计算图的静态框架，让tensor在计算图上前向流动，进行计算
  - 诸如keras的tf2是pytorch类似，是动态运算框架

- 是否了解多GPU训练的同步模式与异步模式
  - 在并行化地训练深度学习模型时，不同设备（GPU或CPU），可以在不同训练数据上，运行这个迭代的过程，而不同并行模式的区别在于，不同的参数更新方式。 
  - 异步模式
    - ![](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2750310363,2906675438&fm=173&s=8E8E7C2329D948CA0C7545DA0000C0B2&w=598&h=306&img.JPEG)
    - 从异步模式的训练流程图中可以看到，在每一轮迭代时，不同设备会读取参数最新的取值。但因为不同设备，读取参数取值的时间不一样，所以得到的值也有可能不一样。根据当前参数的取值，和随机获取的一小部分训练数据，不同设备各自运行反向传播的过程，并独立地更新参数。
  - 同步模式
    - ![](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=615166701,2550626959&fm=173&s=3EAA702331CFC0EA0EF445DA0000C0B1&w=460&h=270&img.JPEG)
    - 在同步模式下，所有的设备同时读取参数的取值，并且当反向传播算法完成之后同步更新参数的取值。单个设备不会单独对参数进行更新，而会等待所有设备都完成反向传播之后计算出不同设备上参数梯度的平均值，最后再根据平均值对参数进行更新。 

### 我的问题

- 想进一步了解部门的工作内容，会做什么事情
  - 为京东集团电商场景的广告提供算法平台（不涉及研究具体的算法，提升效果）
  - 支持模型团队依托我们的平台进行建模
  - 后端使用tensorflow，我理解像是基于tf框架开发一个算法训练平台，支持特征提取，样本拼接等

## HR面

- 在实习过程中有没有遇到困难，是怎么解决的？
  - 刚进入公司的时候需要学习很多东西，除了了解手头的业务，还要学习繁杂的代码，了解公司行政制度，团队及部门的定位，大家目前为止的工作进度。
  - 对手头需要学习的繁杂项目代码，多花时间进行阅读，梳理其中的核心逻辑；对工作中不了解的内容和行话，查阅相关文档，获取context；通过浏览部门周报了解大家的工作进度；通过就餐及散步时与同事交流了解业务情况及团队与部门定位；遇到重要但查不到的内容，咨询相关同事和mentor；
- 和老师意见分歧时如何沟通
  - 首先在双方之间进行充分沟通，确保师生互相了解彼此的想法和对事情上下文的认知，避免由于信息不对等造成分歧。如果觉得自己更有道理，会据理力争。如果拿不出能比较好地支撑自己观点的依据，则倾向于认同老师的意见，毕竟老师的人生阅历更为丰富，入行也更早，了解自己不知道的事情很正常。
- 在人群中是一个什么样的角色
  - 无论是做为领导者还是“打工人”，都会认真做好自己的工作
  - 在实验室，社团及班级当中均担任过管理职位。自己会站在比较高的位置思考团队前进的方向并制定好相应规划，在举办活动时能做好组织与策划的工作，布置工作时也能将工作内容顺利安排给同学们，并得到比较好的反馈。
  - 在公司实习的时候，会一丝不苟的对待交给自己的工作内容，不懂的地方认真钻研，督促自己不断学习进步。尽可能地写出质量高，扩展性好，鲁棒性与可读性强的代码，能够清晰地向上级汇报自己的工作内容。
- 你了解我们部门吗
  - 通过之前与二位面试官的交流我对这个部门有了充分的了解
  - 部门叫什么，定位是什么，大家在做什么事情，自己进去会做什么工作，工作中会涉及什么技术都可以简单说一下
- 你的学习这么好，有什么学习方法吗
  - 课上认真听讲，课下认真复习（我不信🤦‍）
  - 对自己学习到的知识，会进行分门别类的归纳总结。在庞杂的知识和事物当中抽象出具有层次结构的大小点及其中的共性与个性。这种方法可以事半功倍地提升自己的学习效率。
  - 不会在意自己和其他人之间排名的前前后后，认真做好自己的工作，不骄不躁，将该学会和该做好的事情学会做好。同时，不比较不代表不努力，自己投身去做的事情会有头有尾有热情且认真负责地完成。
  - 好记性不如烂笔头，相比于阅读和打字，将文字记录在笔记上能记忆的更清晰牢固。在学习或读书的过程中如果有些联想，灵光或是感悟，都会在旁边做备注，记录下当时的所思所想。

### 我的问题

- 工作地点
  - 北京北辰
- 可提前实习
- 有食堂也有餐补
